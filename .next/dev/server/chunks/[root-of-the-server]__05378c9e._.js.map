{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/Shortner-updated/git/app/api/login/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport crypto from 'crypto';\n\n/**\n * POST handler for user login. Expects a JSON payload containing a\n * username and password. If the credentials are valid, a cookie\n * named `username` is set on the response which is used to\n * authenticate subsequent API requests. Passwords are stored as\n * SHA-256 hashes in the `data/users.json` file.\n */\nexport async function POST(req: NextRequest) {\n  try {\n    const { username, password } = await req.json();\n    if (typeof username !== 'string' || typeof password !== 'string' || !username || !password) {\n      return NextResponse.json({ error: 'Invalid request' }, { status: 400 });\n    }\n    const dataDir = path.join(process.cwd(), 'data');\n    await fs.mkdir(dataDir, { recursive: true });\n    const usersFile = path.join(dataDir, 'users.json');\n    let users: Record<string, string> = {};\n    try {\n      users = JSON.parse(await fs.readFile(usersFile, 'utf8'));\n    } catch {\n      users = {};\n    }\n    const storedHash = users[username];\n    if (!storedHash) {\n      return NextResponse.json({ error: 'Invalid username or password' }, { status: 401 });\n    }\n    const providedHash = crypto.createHash('sha256').update(password).digest('hex');\n    if (providedHash !== storedHash) {\n      return NextResponse.json({ error: 'Invalid username or password' }, { status: 401 });\n    }\n    // Set the username cookie. We deliberately do not mark it as\n    // httpOnly so that client-side fetch requests can include it\n    // automatically. Adjust maxAge as needed (e.g. session cookie).\n    const res = NextResponse.json({ success: true });\n    res.cookies.set('username', username, { path: '/' });\n    return res;\n  } catch (err) {\n    console.error('POST /api/login error:', err);\n    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AASO,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,IAAI;QAC7C,IAAI,OAAO,aAAa,YAAY,OAAO,aAAa,YAAY,CAAC,YAAY,CAAC,UAAU;YAC1F,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAkB,GAAG;gBAAE,QAAQ;YAAI;QACvE;QACA,MAAM,UAAU,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;QACzC,MAAM,gIAAE,CAAC,KAAK,CAAC,SAAS;YAAE,WAAW;QAAK;QAC1C,MAAM,YAAY,4GAAI,CAAC,IAAI,CAAC,SAAS;QACrC,IAAI,QAAgC,CAAC;QACrC,IAAI;YACF,QAAQ,KAAK,KAAK,CAAC,MAAM,gIAAE,CAAC,QAAQ,CAAC,WAAW;QAClD,EAAE,OAAM;YACN,QAAQ,CAAC;QACX;QACA,MAAM,aAAa,KAAK,CAAC,SAAS;QAClC,IAAI,CAAC,YAAY;YACf,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA+B,GAAG;gBAAE,QAAQ;YAAI;QACpF;QACA,MAAM,eAAe,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,UAAU,MAAM,CAAC;QACzE,IAAI,iBAAiB,YAAY;YAC/B,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA+B,GAAG;gBAAE,QAAQ;YAAI;QACpF;QACA,6DAA6D;QAC7D,6DAA6D;QAC7D,gEAAgE;QAChE,MAAM,MAAM,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAK;QAC9C,IAAI,OAAO,CAAC,GAAG,CAAC,YAAY,UAAU;YAAE,MAAM;QAAI;QAClD,OAAO;IACT,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF","debugId":null}}]
}