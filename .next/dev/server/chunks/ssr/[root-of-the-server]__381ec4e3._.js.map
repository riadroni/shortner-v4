{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 24, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/Shortner-updated/git/app/%5Bid%5D/RedirectComponent.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/app/[id]/RedirectComponent.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/[id]/RedirectComponent.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAkS,GAC/T,gEACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/Shortner-updated/git/app/%5Bid%5D/RedirectComponent.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/app/[id]/RedirectComponent.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/[id]/RedirectComponent.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAA8Q,GAC3S,4CACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/Shortner-updated/git/app/%5Bid%5D/page.tsx"],"sourcesContent":["import fs from \"fs/promises\";\nimport path from \"path\";\nimport { notFound } from \"next/navigation\";\nimport RedirectComponent from \"./RedirectComponent\";\n\n// Force runtime rendering and disable static regeneration. Without this,\n// Next.js may try to pre-render pages and not pick up new entries in\n// the JSON file, which would lead to a 404 for dynamic ids.\nexport const dynamic = 'force-dynamic';\nexport const revalidate = 0;\n\ninterface LinkEntry {\n  id: string;\n  image: string;\n  urlMobile: string;\n  urlDesktop?: string;\n}\n\n/**\n * Server component that resolves the provided id to a stored link entry.\n *\n * If the id exists in the data store, it renders a client component that\n * displays the loading image and performs a timed redirect. Otherwise it\n * triggers the notFound() helper to render the 404 page.\n */\nexport default async function Page({ params }: { params: Promise<{ id: string }> }) {\n  // Params is a promise in Next.js 15; we must await it to retrieve the id\n  const { id } = await params;\n  const dataFile = path.join(process.cwd(), 'data', 'links.json');\n  // Read the data file. If it's missing or invalid, initialise linksData to\n  // an empty object instead of returning early. This avoids inadvertently\n  // triggering a 404 due to a parse error or missing file.\n  let linksData: Record<string, any> = {};\n  try {\n    const json = await fs.readFile(dataFile, 'utf8');\n    linksData = JSON.parse(json);\n  } catch {\n    linksData = {};\n  }\n  // Determine if the data is flat or nested. If flat, look up the id\n  // directly. If nested, search through all user namespaces to find\n  // the entry. If not found return a 404.\n  const hasFlatEntries = Object.values(linksData).some(\n    (v: any) => v && typeof v === 'object' && 'id' in v\n  );\n  let entry: LinkEntry | undefined;\n  if (hasFlatEntries) {\n    entry = linksData[id] as LinkEntry;\n  } else {\n    for (const user of Object.keys(linksData)) {\n      const userEntries = linksData[user] ?? {};\n      if (userEntries && typeof userEntries === 'object' && id in userEntries) {\n        entry = userEntries[id] as LinkEntry;\n        break;\n      }\n    }\n  }\n  if (!entry) {\n    return notFound();\n  }\n  return (\n    <RedirectComponent\n      image={entry.image}\n      urlMobile={entry.urlMobile}\n      urlDesktop={entry.urlDesktop}\n    />\n  );\n}"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AAAA;AACA;;;;;;AAKO,MAAM,UAAU;AAChB,MAAM,aAAa;AAgBX,eAAe,KAAK,EAAE,MAAM,EAAuC;IAChF,yEAAyE;IACzE,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;IACrB,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ;IAClD,0EAA0E;IAC1E,wEAAwE;IACxE,yDAAyD;IACzD,IAAI,YAAiC,CAAC;IACtC,IAAI;QACF,MAAM,OAAO,MAAM,gIAAE,CAAC,QAAQ,CAAC,UAAU;QACzC,YAAY,KAAK,KAAK,CAAC;IACzB,EAAE,OAAM;QACN,YAAY,CAAC;IACf;IACA,mEAAmE;IACnE,kEAAkE;IAClE,wCAAwC;IACxC,MAAM,iBAAiB,OAAO,MAAM,CAAC,WAAW,IAAI,CAClD,CAAC,IAAW,KAAK,OAAO,MAAM,YAAY,QAAQ;IAEpD,IAAI;IACJ,IAAI,gBAAgB;QAClB,QAAQ,SAAS,CAAC,GAAG;IACvB,OAAO;QACL,KAAK,MAAM,QAAQ,OAAO,IAAI,CAAC,WAAY;YACzC,MAAM,cAAc,SAAS,CAAC,KAAK,IAAI,CAAC;YACxC,IAAI,eAAe,OAAO,gBAAgB,YAAY,MAAM,aAAa;gBACvE,QAAQ,WAAW,CAAC,GAAG;gBACvB;YACF;QACF;IACF;IACA,IAAI,CAAC,OAAO;QACV,OAAO,IAAA,iMAAQ;IACjB;IACA,qBACE,8OAAC,8IAAiB;QAChB,OAAO,MAAM,KAAK;QAClB,WAAW,MAAM,SAAS;QAC1B,YAAY,MAAM,UAAU;;;;;;AAGlC","debugId":null}}]
}